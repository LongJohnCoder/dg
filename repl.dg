import '/re'
import '/sys'
import '/types'
import '/signal'
import '/asyncio'
import '/builtins'

import 'BUILTINS'
import 'Name'
import 'LeftBind'
import 'Expression'
import 'Compiler'
import 'parse'
import 'compilefd'
import 'compileast'


except
  _err => import 'readline'
  _err :: ImportError =>
    Teletype = subclass object where __init__ = _ _ loop: None ~> None
    Readline = subclass object where __init__, input = (,)
      _ ~> None
      p ~>
        False => yield 0
        builtins.input p

    runasync = coro loop: None ->
      except err => while True => next coro
             err :: StopIteration => err.args !! 0

  _err is None =>
    runasync = coro loop: None ->
      # If an exception, such as KeyboardInterrupt, occurs within the loop
      # but not in a task, it'll break everything, as finalizers never get executed.
      loop = loop or asyncio.get_event_loop!
      task = asyncio.async coro loop: loop
      task.add_done_callback $ _ -> loop.stop!
      except
        err => loop.run_forever!
        finally => err =>
          # This will ensure clean finalization.
          task.cancel!
          loop.run_forever!
      task.result!


    #: Get a set of attributes of an object. `path` should be a dotted name.
    #:
    #: _attributes_of :: str (dict str object) -> set str
    #:
    _attributes_of = path ns -> except
      err =>
        item = eval (compileast $ parse path) ns
        if not $ item :: types.ModuleType => dir item
           # Hide dg built-ins, which are inserted into every global namespace
           # (because CPython cannot destroy `__builtins__` properly on shutdown.)
           otherwise =>
             filter (x -> not $ x in BUILTINS and getattr item x is BUILTINS !! x) $ dir item
      err :: Exception => set!

    Teletype = subclass readline.Teletype where
    Readline = subclass readline.mix.History readline.mix.Completer readline.Readline where
      # Matches any number of valid dg identifiers separated by dots.
      # (No whitespace!)
      completion_regex = re.compile r"\w+'*(?:\.\w+'*)*\.?"

      # This attribute must be set to the global namespace.
      # Otherwise, variables defined from within the REPL will not be completed.
      completion_ns = dict!

      # Display only the attribute name when listing possible completions.
      # The rest (i.e. the object itself) is irrelevant and is always the same.
      display_completions = cmps ~>
        (super Readline self).display_completions $
          list $ map (x -> last $ x.split '.') cmps

      # Complete a variable or an attribute name (i.e. `VAR.VAR....[VAR]`.)
      # This method simulates `rlcompleter`. (It can even evaluate arbitrary
      # code via `__getattr__`, too. WARNING, I guess.)
      complete_word = word ~>
        path, dot, word = word.rpartition '.'
        filter_fn = if
          # Hide private attributes unless an underscore was typed.
          word      => n -> n.startswith word
          otherwise => n -> not $ n.startswith '_'
        sorted $ map (path + dot +) $ filter filter_fn $
          if path      => _attributes_of path @completion_ns
             otherwise => set Compiler.prefix | set builtins.__dict__ | set @completion_ns


compilerepl = source -> except
  e =>
    tree = parse source '<input>'
    expr = next $ dropwhile (x -> x :: Expression and not x.closed) $
                  iterate   (x -> last x.args) tree

    # Tap `Return` twice to override any of these checks.
    done = source.endswith '\n' or not
      # There may be an indented block in the next line if
      #     1. the last operator has no right-hand side;
      expr :: LeftBind and not expr.op.norhs or
        #   2. the last expression is accessing a built-in, which
        #      doesn't make sense (unlike a call to that built-in;)
        expr :: Name and not expr.closed and expr.value in Compiler.prefix or
          # 3. the last line of the code is indented.
          (last $ source.rsplit '\n' 1).startswith ' '

    if done => compileast tree
  # Open strings or blocks may be continued, too. (Tapping `Return` won't help.)
  e :: SyntaxError and (head e.args).startswith 'unexpected EOF' => None


runcode = code ->
  md = sys.modules !! '__main__' = types.ModuleType '__main__'
  md.__dict__.update BUILTINS
  md.__file__ = code.co_filename
  eval code md.__dict__


runrepl = fd loop: None ->
  sys.stdin = fd
  sys.ps1   = getattr sys 'ps1' '>>> '
  sys.ps2   = getattr sys 'ps2' '... '
  environ   = (sys.modules !! '__main__' = types.ModuleType '__main__').__dict__
  environ.update BUILTINS

  rdl = Readline $ Teletype sys.stdin sys.stdout loop: loop
  rdl.completion_ns = environ
  environ !! '_async_stdio' = rdl.tty

  while True => except
    e => x = runasync loop: loop $
      where
        i = yield from $ rdl.input sys.ps1
        while not (x = compilerepl i) =>
          i += '\n' + yield from (rdl.input sys.ps2)
        x
    e :: EOFError          => raise SystemExit
    e :: SystemExit        => raise e
    e :: KeyboardInterrupt =>
    e :: BaseException     => sys.excepthook (type e) e e.__traceback__
    e is None => except
      e => sys.displayhook $ eval x environ
      e :: SystemExit    => raise e
      e :: BaseException => sys.excepthook (type e) e e.__traceback__


runfile = fd -> if
  fd.isatty! => runrepl fd
  otherwise  => runcode $ compilefd fd $ getattr fd 'name' '<input>'
