import '/re'
import '/sys'
import '/time'
import '/types'
import '/signal'
import '/asyncio'
import '/builtins'

import 'BUILTINS'
import 'Name'
import 'LeftBind'
import 'Expression'
import 'Compiler'
import 'parse'
import 'compilefd'
import 'compileast'


except
  _err => import 'readline'
  _err :: ImportError =>
    Readline = *: _ **: _ -> subclass object
    _read    = _ _ prompt -> input prompt

  _err is None =>
    _read = rdl loop prompt ->
      _rethrow = None
      loop = loop or asyncio.get_event_loop!
      task = asyncio.async loop: loop $ rdl.input prompt
      task.add_done_callback $ _ -> loop.stop!
      while not task.done! => except
        err => loop.run_forever!
        err :: BaseException =>
          task.cancel!
          _rethrow = err
      if _rethrow  => raise _rethrow
         otherwise => task.result!

    Readline = subclass readline.mix.History readline.mix.Completer readline.Readline where
      # Matches any number of valid dg identifiers separated by dots.
      # (No whitespace!)
      completion_regex = re.compile r"(?:\w+'*\.)*\w+'*"

      # This attribute must be set to the global namespace.
      # Otherwise, variables defined from within the REPL will not be completed.
      completion_ns = dict!

      # Display only the attribute name when listing possible completions.
      # The rest (i.e. the object itself) is irrelevant and is always the same.
      display_completions = cmps ~>
        (super Readline self).display_completions $
          list $ map (x -> last $ x.split '.') cmps

      # Complete a variable or an attribute name (i.e. `(something\.)*something`.)
      # This method simulates `rlcompleter`. (It can even evaluate arbitrary
      # code via `__getattr__`, too. WARNING, I guess.)
      complete_word = word ~>
        path, dot, word = word.rpartition '.'

        filter_fn = if
          # Hide private attributes unless an underscore was typed.
          word      => n -> n.startswith word
          otherwise => n -> not $ n.startswith '_'

        sorted $ map (path + dot +) $ filter filter_fn $ if
          not path  => set Compiler.prefix | set builtins.__dict__ | set @completion_ns
          otherwise => except
            err => obj = foldl (!!) @completion_ns $ path.split '.'
            err :: KeyError => ()
            err is None =>
              # dg inserts its built-ins into global namespaces. Gotta hide these.
              filter (x -> not $ x in BUILTINS and getattr item x is BUILTINS !! x) $ dir obj


compilerepl = source -> except
  e =>
    tree = parse source '<input>'
    expr = next $ dropwhile (x -> x :: Expression and not x.closed) $
                  iterate   (x -> last x.args) tree

    # Tap `Return` twice to override any of these checks.
    done = source.endswith '\n' or not
      # There may be an indented block in the next line if
      #     1. the last operator has no right-hand side;
      expr :: LeftBind and not expr.op.norhs or
        #   2. the last expression is accessing a built-in, which
        #      doesn't make sense (unlike a call to that built-in;)
        expr :: Name and not expr.closed and expr.value in Compiler.prefix or
          # 3. the last line of the code is indented.
          (last $ source.rsplit '\n' 1).startswith ' '

    if done => compileast tree
  # Open strings or blocks may be continued, too. (Tapping `Return` won't help.)
  e :: SyntaxError and (head e.args).startswith 'unexpected EOF' => None


runcode = code ->
  md = sys.modules !! '__main__' = types.ModuleType '__main__'
  md.__dict__.update BUILTINS
  md.__file__ = code.co_filename
  eval code md.__dict__


runrepl = fd loop: None ->
  sys.stdin = fd
  sys.ps1   = getattr sys 'ps1' '>>> '
  sys.ps2   = getattr sys 'ps2' '... '
  environ   = (sys.modules !! '__main__' = types.ModuleType '__main__').__dict__
  environ.update BUILTINS

  rdl = Readline sys.stdin sys.stdout loop
  rdl.completion_ns = environ
  line = bind _read rdl loop

  while True => except
    e => x = next $ filter None $ map compilerepl $ iterate (x -> x + '\n' + line sys.ps2) $ line sys.ps1
    e :: EOFError          => raise SystemExit
    e :: KeyboardInterrupt =>
    e :: BaseException     =>
      sys.excepthook (type e) e e.__traceback__
      # Prevent excessive exception spam if the error is in the REPL.
      time.sleep 0.1  # (At least it won't hang SSH clients and others that way.)
    e is None => except
      e => sys.displayhook $ eval x environ
      e :: SystemExit    => raise e
      e :: BaseException => sys.excepthook (type e) e e.__traceback__


runfile = fd -> if
  fd.isatty! => runrepl fd
  otherwise  => runcode $ compilefd fd $ getattr fd 'name' '<input>'
