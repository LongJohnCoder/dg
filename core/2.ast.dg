#: The set of alphanumeric identifiers that should be nonetheless
#: treated as infix operators. (Normally, alphanumeric names are prefix
#: while punctuation is infix.)
INFIXN = set' 'and' 'in' 'is' 'or' 'where'
#: The set of operators that accept any no. of arguments, mostly for optimization.
#: (Normally, an operator is binary.)
VARARY = set' ',' '\n' ''
#: The set of operators that should not accept a left-hand expression,
#: so `a R b` becomes `a (R b)`.
NOLHS = set' '@' '~'
#: Different side, same story. `a R b` becomes `(a R) b`.
NORHS = set' '!'
#: Operators with these flags behave differently in a null-denotation context.
#: See the parser (`Parser.special`) for details.
FLAGS = dict' ('for', 1) ('while', 1) ('with', 1) ('if', 2) ('except', 2)
#: Infix operator binding strength. `a R b Q c` <=> `a R (b Q c)` iff
#: the left binding strength of `Q` is greater than the right binding strength
#: of `R`; otherwise, it's `(a R b) Q c`.
STRENGTH = dict'
  '@',     (22, 22)
  '.',     (21, 21)
  '!.',    (21, 21)
  '!',     (21, 20)
  ':',     (21, 20)
  '',      (19, 19)
  '->',    (18,  2)
  '~>',    (18,  2)
  '!!',    (17, 17)
  '**',    (17, 16)
  '*',     (15, 15)
  '/',     (15, 15)
  '//',    (15, 15)
  '%',     (15, 15)
  '+',     (14, 14)
  '-',     (14, 14)
  # (13, 13) is the default for everything not listed here.
  '<',     (12, 12)
  '<=',    (12, 12)
  '>',     (12, 12)
  '>=',    (12, 12)
  '==',    (12, 12)
  '!=',    (12, 12)
  'is',    (12, 12)
  'in',    (12, 12)
  '<<',    (11, 11)
  '>>',    (11, 11)
  '&',     (10, 10)
  '^',     ( 9,  9)
  '|',     ( 8,  8)
  'and',   ( 7,  7)
  'or',    ( 6,  6)
  '$',     ( 6,  5)
  '<|',    ( 6,  5)
  '|>',    ( 5,  5)
  '|>.',   ( 5, 21)
  ',',     ( 4,  4)
  '=',     ( 4,  3)
  ':=',    ( 4,  3)
  '!!=',   ( 4,  3)
  '+=',    ( 4,  3)
  '-=',    ( 4,  3)
  '*=',    ( 4,  3)
  '**=',   ( 4,  3)
  '/=',    ( 4,  3)
  '//=',   ( 4,  3)
  '%=',    ( 4,  3)
  '&=',    ( 4,  3)
  '^=',    ( 4,  3)
  '|=',    ( 4,  3)
  '<<=',   ( 4,  3)
  '>>=',   ( 4,  3)
  'where', ( 4,  3)
  'for',   ( 4,  3)
  'while', ( 4,  3)
  'with',  ( 4,  3)
  '=>',    ( 4,  3)
  '\n',    ( 1,  1)


Node = subclass object where
  # These are only used by `Name`s.
  closed = False  # :: bool -- whether the node is parenthesized
  indent = False  # :: bool -- whether the node is indented relative to the surroundings
  infix  = False  # :: bool -- this and below only make sense for `Name`s.
  nolhs  = False  # :: bool -- see `NOLHS`
  norhs  = False  # :: bool -- see `NORHS`
  varary = False  # :: bool -- see `VARARY`
  flags  = 0      # :: int  -- see `FLAGS`


Name = subclass Node where
  __init__ = self @loc infix @value ->
    @infix  = @value in INFIXN or infix
    @nolhs  = @value in NOLHS
    @norhs  = @value in NORHS
    @varary = @value in VARARY
    @flags  = FLAGS.get @value 0
    None

  __lt__   = self x -> STRENGTH.get self (13, 13) !! 1 < STRENGTH.get x (13, 13) !! 0
  __eq__   = self x -> @value == x
  __hash__ = self   -> hash @value
  __repr__ = self   -> if
    @closed   => '(' + @value + ')'
    otherwise =>       @value


Expression = subclass Node where
  __init__ = self @loc @op *: args -> None where @args = list args
  __repr__ = self -> '(' + (repr @op or ' ').join (map repr @args) + ')'


Constant = subclass Node where
  __init__ = self @loc @value -> None
  __repr__ = self -> repr @value


LeftBind = subclass Expression where
  __repr__ = self -> '({[0]!r} {!r})'.format @args @op


RightBind = subclass Expression where
  __repr__ = self -> '({!r} {[0]!r})'.format @op @args


Ending = subclass Node where
  __init__ = self @loc @value -> None
  __repr__ = self -> '<Ending: {!r}>'.format @value


#: Given some expressions joined by infix commas, convert them into expression
#: joined by infix operator `name`. Intended to be used as a block handler; e.g.
#: a []-block would use that to convert a tuple into a list at compile-time.
#: See `Parser.blkinds`.
#:
#: tuple_into :: str -> (str, int, int, str) Node -> Node
#:
tuple_into = name -> pos x -> Expression x.loc (Name x.loc True name) *:
  if x :: Constant   and x.value is None              => ()
     x :: LeftBind   and x.op == ','                  => x.args
     x :: Expression and x.op == ',' and not x.closed => x.args
     otherwise => raise $ SyntaxError 'not a comma-separated list' pos
