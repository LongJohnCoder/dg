import '/importlib'
import '/itertools'
import '/posixpath'

ANY = float 'inf'


#: Compile some source code.
#:
#: compile :: str (Optional str) (Optional (iter str)) -> types.CodeType
#:
compile = data filename: '<string>' ns: () -> compileast ns: ns $ parse data filename


#: Compile the contents of a file-like object.
#:
#: compilefd :: TextIOBase (Optional str) (Optional (iter str)) -> types.CodeType
#:
compilefd = fd filename: '<stream>' ns: () -> compileast ns: ns $ parsefd fd filename


#: Compile an AST into Python bytecode.
#:
#: compileast :: Node (Optional (iter str)) -> types.CodeType
#:
compileast = x ns: () ->
  self = Compiler ''
  @globals = set ns | set (@symbols x)
  @pushast x
  @append 'RETURN_VALUE' delta: -1
  @frozen


#: Raise a SyntaxError.
#:
#: Error :: Node str -> a
#:
Error = at description -> raise $ SyntaxError description at.loc


#: Enforce arbitrary argument count limits on a compile-time function.
#:
#: `ANY` for `max` means "the function is variadic".
#:
#: FixedArity :: int int Handler -> Handler
#:
FixedArity = min max h -> f args ~>
  len args < min => Error f $ 'got {1} arguments, min. {0}'.format min $ len args
  len args > max => Error f $ 'got {1} arguments, max. {0}'.format max $ len args
  h self f args


#: Make a handler update its first argument with the result.
#:
#: Inplace :: Handler -> Handler
#:
Inplace = h -> f xs ~>
  h self f xs
  @append 'DUP_TOP' 0 +1
  @popast $ head xs


#: Turn a function that takes node pairs into one that takes `u => v` nodes.
#:
#: ArrowPairs :: (Node [(Node, Node)] -> a) -> Handler
#:
ArrowPairs = h -> f xs ~>
  not $ getattr f '_handled' False =>
    if len xs == 1 and head xs :: Expression and (head xs).op == '' => xs = (head xs).args
    f._handled  = True
    f._arrpairs = list
      where for x in xs => yield $ if
        x :: RightBind  and x.op == '=>' => Error x 'missing expression'
        x :: LeftBind   and x.op == '=>' => x.args + list' (Constant x.loc None)
        x :: Expression and x.op == '=>' => x.args
        otherwise => Error x 'expected `u => v`'
  h self f f._arrpairs


#: Raise a `SyntaxError` regardless of arguments.
#:
#: WithError :: str -> Handler
#:
WithError = x -> f xs ~> Error f x


#: Apply a single bytecode instruction to all arguments.
#:
#: WithOpcode :: str -> Handler
#:
WithOpcode = x -> f xs ~>
  @pushlist xs
  @append x (len xs) $ 1 - len xs


#: Take the first argument that doesn't match a jump condition.
#:
#: WithJump :: str -> Handler
#:
WithJump   = x -> FixedArity 2 2 $ f (a, b) ~> (@pushast a, with @jump x False -1 => @pushast b)
Comparison =      FixedArity 2 2 $ f (a, b) ~>
  chain = list!
  while a :: Expression and not a.closed and @prefix.get a.op.value is Comparison =>
    chain.insert 0 (a.op, snd a.args)
    a = fst a.args

  @pushast a
  jumps = list
    where for (op, arg) in chain => yield $
      @pushast arg
      @append  'DUP_TOP'    delta: +1 #=> a, b, b
      @append  'ROT_THREE'  delta: +0 #=> b, a, b
      @append  'COMPARE_OP' delta: -1 $ dis.cmp_op.index op.value
      @jump    'JUMP_IF_FALSE_OR_POP' delta: -1
  @pushast b
  @append 'COMPARE_OP' delta: -1 $ dis.cmp_op.index f.value

  if jumps => with @jump 'JUMP_FORWARD' =>
    for j in jumps => j.set
    @append 'ROT_TWO'
    @append 'POP_TOP'  # stack size change was accounted for by @jump


#: Parse function definition arguments.
#:
#: positional1 (positional2, iterable): default_value *: varargs keyword_only **: varkwargs
#:
#: DEFNARGS :: Node -> ([str], [str], [Node], {str: Node}, [str], [str], {str: Node})
#:
DEFNARGS = xs -> a, kw, da, dkw, va, vkw, add where
  a    = list!  # positional
  kw   = list!  # keyword-only
  da   = list!  # default values
  dkw  = dict!  # default values for keyword-only arguments
  va   = list!  # varargs (a singleton)
  vkw  = list!  # varkwargs (a singleton)
  add  = dict!  # (name -> pattern) mapping

  pattern = i x -> if
    x :: Name => if
      x in a + kw + va => Error x 'duplicate argument name'
      x == '_'         => 'ignore:{}'.format i
      otherwise        => x.value
    otherwise => name where add !! (name = 'pattern:{}'.format i) = x

  data = if xs :: Expression and not xs.closed and xs.op == '' => xs.args
            otherwise                                          => list' xs

  for (i, x) in enumerate data => if
    x :: Expression and x.op == ':' => if
      x :: LeftBind  => Error x 'default value missing'
      x :: RightBind => Error x 'argument name missing'
      fst x.args == '*' =>
        va => Error x 'can only have one `*: x`'
        va.append $ pattern i $ snd x.args
      fst x.args == '**' =>
        vkw => Error x 'can only have one `**: x`'
        vkw.append $ pattern i $ snd x.args
      va =>
        k, v = x.args
        k :: Name or Error k 'keywords should be identifiers'
        kw.append name where dkw !! (name = pattern i k) = v
      otherwise =>
        a.append $ pattern i $ fst x.args
        da.append $ snd x.args
    va => kw.append $ pattern i x
    da => Error x 'this argument must have a default value'
    otherwise => a.append $ pattern i x

  len a  > 255 => Error xs 'too many positional arguments'
  len kw > 255 => Error xs 'too many keyword arguments'


Compiler = subclass CodeType where
  __init__ = *: args **: kwargs ~>
    (super Compiler self).__init__ *: args **: kwargs
    @loops = list!
    None

  #: Push the result of evaluating `x` onto the stack.
  #:
  #: pushast :: Node -> a
  #:
  pushast = x ~>
    x.loc => if
      @lineoff == -1 =>
        @filename = x.loc !! 0
        @lineno   = x.loc !! 1
        @lineoff  = x.loc !! 1
      otherwise =>
        lineoff = x.loc !! 1 - @lineoff
        lineoff > 0 =>
          byteoff = codelen $ drop @byteoff @bytecode
          byteoff > 0 =>
            @lineoff = x.loc !! 1
            @byteoff = len @bytecode
            @lnotab += lineoff // 256 * b'\x00\xff'
            @lnotab += byteoff // 256 * b'\xff\x00'
            @lnotab += bytes (byteoff % 256, lineoff % 256)

    if x :: Name       => @pushname  x.value at: x.loc
       x :: Constant   => @pushconst x.value
       x :: LeftBind   => @pushbind  False x.op *: x.args
       x :: RightBind  => @pushbind  True  x.op *: x.args
       x :: Expression => @pushcall  x.op *: x.args
       otherwise       => raise $ TypeError 'invalid node' $ type x

  #: Push some string-object pairs.
  #:
  #: Used by keyword arguments and annotations.
  #:
  pushkeys = xs ~> for (k, v) in xs =>
    @pushconst k
    @pushast   v

  #: Push multiple items in one go.
  #:
  #: pushlist :: [Node] -> a
  #:
  pushlist = xs ~> for x in xs => @pushast x

  #: Evaluate multiple expressions, discarding all results but the last.
  #:
  #: pushlast :: *Node -> a
  #:
  pushlast = *: (*xs, y) ~>
    for x in xs =>
      @pushast x
      @append 'POP_TOP' delta: -1
    @pushast y

  #: Create a function out of a code object.
  #:
  #: pushclosure :: CodeType [Node] (dict str Node) -> a
  #:
  pushclosure = code defaults kwdefaults ~>
    code.append 'RETURN_VALUE' delta: -1
    const = code.frozen
    @pushkeys  kwdefaults.items!
    @pushlist  defaults
    @pushcells const.co_freevars
    @append    'BUILD_TUPLE' (len const.co_freevars) $ 1 - len const.co_freevars
    @pushconst const
    @pushconst code.qualname
    @append    'MAKE_CLOSURE'
      0 + len defaults + 256 * len kwdefaults
      0 - len defaults - 2   * len kwdefaults - 2

  #: Push the result of calling `f` with `args` onto the value stack.
  #:
  #: pushcall :: Node *Node -> a
  #:
  pushcall = f *: args ~> if
    f :: Name and f.value in @prefix => (@prefix !! f.value) self f args
    # Infix functions don't get fancy syntax.
    # When using infix operators, varargs and keyword arguments are disabled.
    f.infix and not f.closed =>
      @pushast  f
      @pushlist args
      @append 'CALL_FUNCTION' (len args) (-len args)
    otherwise =>
      @pushast f
      @pushcalltop 0 args

  #: Push the result of calling a function from the top of the stack.
  #:
  #: Additional arguments may be taken from there, too.
  #:
  #: pushcalltop :: int [Node] -> a
  #:
  pushcalltop = argc argv ~>
    kw = dict!

    for x in argv => if
      x :: Expression and x.op == ':' => if
        x :: LeftBind      => Error x 'keyword without a value'
        x :: RightBind     => Error x 'keyword missing'
        fst x.args in kw   => Error x 'keywords should be unique'
        fst x.args :: Name => kw !! (fst x.args).value = snd x.args
        otherwise          => Error x 'keywords should be identifiers'
      otherwise => @pushast x

    argc += len argv - len kw
    argc   > 255 => Error (fst argv) 'too many positional arguments'
    len kw > 255 => Error (fst argv) 'too many keyword arguments'
    va  = kw.pop '*'  None
    vkw = kw.pop '**' None

    @pushkeys kw.items!
    va  => @pushast va
    vkw => @pushast vkw
    @append
      'CALL_FUNCTION' + '_VAR' * bool va + '_KW' * bool vkw
      0 + argc + 256 * len kw
      0 - argc - 2   * len kw - bool va - bool vkw

  #: Default infix bind implementation.
  #:
  #: `x R` <=> `y -> x R y`
  #: `R x` <=> `y -> y R x`
  #:
  #: pushbind :: bool Node Node -> a
  #:
  pushbind = right f arg ~> if
    f.value in @infixl and not right => (@infixl !! f.value) self f arg
    f.value in @infixr and     right => (@infixr !! f.value) self f arg
    f.value in @prefix and not (f.value in BUILTINS) =>
      # Note that partial binding of macros does not actually use
      # runtime functions (as `pushcall` will prefer compile-time ones.)
      # Still, this is a pretty good method of checking if
      # someone's attempting to partially bind assignment operators, etc.
      Error f 'this operator requires both arguments'
    otherwise =>
      c = if right     => @spawn f.value ('<L>',) ('<R>',)
             otherwise => @spawn f.value ('<R>',) ('<L>',)
      c.pushcall f (Name f.loc False '<L>') (Name f.loc False '<R>')
      @pushclosure c tuple! $ dict' $ if right     => '<R>', arg
                                         otherwise => '<L>', arg

  #: Create a function.
  #:
  #: pushfunc :: Node Node -> a
  #:
  pushfunc = args body ~> @pushfunc' body *: (DEFNARGS args)

  #: Create a function with known arguments.
  #:
  #: pushfunc' :: Node [str] [str] [Node] (dict str Node) [str] [str] (dict str Node) -> a
  #:
  pushfunc' = body a kw da dkw va vkw patterns ~>
    g = @spawn '<lambda>' a kw va vkw
    g.regsyms body
    for (_, v) in patterns.items! => for a in @popast_symscan v => g.varnames !! a
    for (k, v) in patterns.items! =>
      g.pushname k
      g.popast   v
    g.pushast body
    @pushclosure g da dkw

  #: Create a method (a function with an additional argument named "self".)
  #:
  #: pushmeth :: Node Node -> a
  #:
  pushmeth = args body ~>
    a, *xs = DEFNARGS args
    a.insert 0 'self'
    @pushfunc' body a *: xs

  #: Push a result of try-except-finally onto the stack.
  #:
  #: Returns the same value as `pushexcept`. `finally` is evaluated in the end,
  #: but the value it returns is ignored.
  #:
  #: pushfinally :: Node Node [(Node, Node)] Node -> a
  #:
  pushfinally = name try cases finally ~>
    # Blindly copied from Python by `diff`ing
    # disassembly of code with `finally` and without one.
    with @jump 'SETUP_FINALLY' delta: +3 =>
      @pushexcept name try cases
      @append 'POP_BLOCK'
      @pushconst None
    # `break` and `continue` should not be used in `finally`.
    _loops, @loops = @loops, list!
    @pushast finally
    @loops = _loops
    @append 'POP_TOP'     delta: -1
    @append 'END_FINALLY' delta: -4

  #: Push a result of try-except onto the stack.
  #:
  #: If any condition matched, the assigned action is evaluated and its value
  #: returned. If not, but no exception was raised, the value of `try` is
  #: returned instead. (`name` is where the exception [or None] is stored.)
  #:
  #: pushexcept :: Node Node [(Node, Node)] -> a
  #:
  pushexcept = name try cases ~>
    main = @jump 'SETUP_EXCEPT' delta: +8  # +what?
    @pushast try
    @append 'ROT_TWO'   delta: +0
    @append 'POP_BLOCK' delta: -1
    # There was no exception, we'll store None instead.
    # The second one will be used to skip over POP_EXCEPT or
    # consumed by END_FINALLY.
    @pushconst None
    @pushconst None
    @popast name

    with @jump 'JUMP_FORWARD' =>
      # Finishing SETUP_EXCEPT with an exception pushes
      # 3 items onto the stack: traceback, value, type.
      # Value needs to be stored in `name`.
      main.set
      @append 'ROT_TWO' delta: +0
      @append 'DUP_TOP' delta: +1
      @popast name
      @append 'ROT_TWO' delta: +0
      @pushconst True  # This will trigger POP_EXCEPT.

    jumps = list
      where for (cond, action) in cases =>
        @pushast cond
        with @jump 'POP_JUMP_IF_FALSE' delta: -1 =>
          @pushast action
          yield $ @jump 'JUMP_FORWARD' delta: -1

    # Disable POP_EXCEPT by popping True off the stack.
    # Only happens if there was an exception.
    with @jump 'JUMP_IF_FALSE_OR_POP' delta: -1 => None
    # This will re-raise the exception if there was one.
    # Otherwise, it will pop None off the stack.
    @append 'END_FINALLY' delta: -9

    with @jump 'JUMP_FORWARD' =>
      # If a handler was triggered, there's now a return value
      # on top of the stack. It needs to be stored for safekeeping.
      for j in jumps => j.set
      @append 'STORE_FAST' $ @varnames !! '<except-result>'
      # Traceback, value, and type may still be on stack.
      # They didn't stop existing or anything.
      with @jump 'POP_JUMP_IF_FALSE' => @append 'POP_EXCEPT'
      @append 'POP_TOP'  # There goes the result of the try clause.
      @append 'LOAD_FAST'   $ @varnames !! '<except-result>'
      @append 'DELETE_FAST' $ @varnames !! '<except-result>'

  #: Check that a condition for a value on top of the stack is true.
  #:
  #: asserttop :: Node str (-> b) -> a
  #:
  asserttop = x err check ~>
    @pushast x
    @append  'DUP_TOP_TWO' delta: 2
    check!   # delta: -1
    with @jump 'POP_JUMP_IF_TRUE' delta: -1 =>
      @pushname err
      @append   'ROT_THREE'
      @append   'CALL_FUNCTION' 2 delta: -2
      @append   'RAISE_VARARGS' 1 delta: -1
    @append 'POP_TOP' delta: +1  # offset the -2 from the `with` branch

  #: Pop a value off the stack and store it somewhere.
  #:
  #: popast :: Node -> a
  #:
  popast = x ~> if
    x :: Name => @popname x.value
    x :: Constant or (x :: Name and x in CONSTANTS) =>
      @asserttop x 'ConstantPatternError' $ ->
        # assert x == top()
        @append  'COMPARE_OP' delta: -1 $ dis.cmp_op.index '=='
      @append 'POP_TOP' delta: -1

    x :: LeftBind => if
      x.op == ',' =>
        @append 'UNPACK_SEQUENCE' 1
        @popast $ fst x.args

      x.op == '!' =>
        @asserttop (fst x.args) 'InstancePatternError' $ ->
          @pushname '::'
          @append   'ROT_THREE'
          @append   'CALL_FUNCTION' 2 delta: -2
        @append 'POP_TOP' delta: -1
      otherwise => Error x 'not something one can assign to'

    x :: RightBind => if
      # A single item prefixed with an at sign is a shorthand
      # for attribute assignment. That is, `self.attribute = ...`.
      x.op == '@' =>
        attr, = x.args
        attr :: Name or Error attr 'not an attribute'
        @pushname 'self' at: x.loc
        @append   'STORE_ATTR' delta: -2 $ @names !! attr.value

      # A single item prefixed with a star.
      #
      # In a comma-separated list, that is an instruction to put excess
      # items in this variable as a list. When there are no other elements,
      # however, the star does nothing.
      #
      x.op == '*' => @popast $ head x.args
      otherwise   => Error x 'not something one can assign to'

    x :: Expression => if
      # T a b c = x
      #
      # => not $ x :: T => raise PatternError
      #    a, b, c = x
      #
      x.op == '' =>
        @asserttop (x.args.pop 0) 'InstancePatternError' $ ->
          # assert top() :: fst x.args
          @pushname '::'
          @append   'ROT_THREE'
          @append   'CALL_FUNCTION' 2 delta: -2
        x.op.value = ','
        @popast x

      # x: y = z
      #
      # => x = y = z
      #
      x.op == ':' =>
        @append 'DUP_TOP' delta: 1
        @popast $ fst x.args
        @popast $ snd x.args

      # A comma-separated list of assignment targets.
      #
      # 1. Assume the value on top of the stack is an iterable.
      # 2. Split it into separate items.
      # 3. Store each of them in an assignment target from this list.
      #
      x.op == ',' =>
        sz = len x.args
        qs = list (where for (i, q) in enumerate x.args =>
          if q :: RightBind and q.op == '*' => yield i)

        if len qs > 1 => Error (x.args !! (qs !! 1)) 'cannot unpack into more than 1 list'
           len qs < 1 => @append delta: (sz - 1) 'UNPACK_SEQUENCE' sz
           otherwise  => @append delta: (sz - 1) 'UNPACK_EX' $ i + 256 * (sz - i - 1) where
             i = head qs
        for a in x.args => @popast a

      x.op == '.' =>
        item, attr = x.args
        attr :: Name or Error attr 'not an attribute'
        @pushast item
        @append  'STORE_ATTR' delta: -2 $ @names !! attr.value

      x.op == '!!' =>
        @pushlist x.args
        @append   'STORE_SUBSCR' delta: -3
      otherwise => Error x 'not something one can assign to'
    otherwise => Error x 'not something one can assign to'

  #: Push something, then store it somewhere.
  #:
  #: pushpop :: Node Node -> a
  #:
  pushpop = name value ~>
    @var, x = repr name, @var
    @pushast value
    @var = x
    @append 'DUP_TOP' delta: +1
    @popast name

  #: Find all local assignments in an AST.
  #:
  #: symbols :: object -> [str]
  #:
  symbols = x ~>
    x :: Expression => if
      x.op :: Name and x.op.value in @symscan =>
        fn = @symscan !! x.op.value
        for a in fn self x.op x.args => yield a
      otherwise =>
        for a in @symbols x.op => yield a
        for q in x.args => for a in @symbols q => yield a

  #: Register all symbols for later use.
  #:
  #: regsyms :: Node -> a
  #:
  regsyms = x ~> for n in @symbols x => @varnames !! n

  #: Symbol scanner for `popast`. Returns an iterator of all changed variables.
  #:
  #: popast_symscan :: Node -> iter str
  #:
  popast_symscan = nm ~> if
    nm :: Expression => if
      nm.op == ','  => for x in nm.args => for a in @popast_symscan x => yield a
      nm.op == '*'  => for x in nm.args => for a in @popast_symscan x => yield a
      nm.op == ':'  => for x in nm.args => for a in @popast_symscan x => yield a
      nm.op == ''   => for x in tail nm.args => for a in @popast_symscan x => yield a
      otherwise     => for a in @symbols nm => yield a
    nm :: Name => yield nm.value

  symscan = dict'
    '',  f args ~> @symbols $ Expression f.loc *: args

    '=', FixedArity 2 2 $ f (n, x) ~>
      for a in @popast_symscan n => yield a
      for a in @symbols        x => yield a

    ':=', FixedArity 2 2 $ f (n, x) ~>
      for a in @popast_symscan n => not $ a in @enclosed => yield a
      for a in @symbols x        => yield a

    'for', FixedArity 1 2 $ f (var, *body) ~>
      not $ var :: Expression and var.op == 'in' and len var.args == 2 => Error var $ if
        # In Python, `in` has a higher precedence than `,`. That is,
        # if you simply write `a, b in c` you get `a, (b in c)`. `for a, b in c:`
        # is merely a special case in the parser; dg has no such thing.
        var :: Expression and var.op == ',' and not var.closed => 'forgot the parentheses?'
        otherwise => 'should be `a in b`'

      v, e = var.args
      for a in @popast_symscan v => yield a
      for a in @symbols        e => yield a
      for x in body => for a in @symbols x => yield a

    'except', FixedArity 1 ANY $ ArrowPairs $ f ((e, x), *y) ~>
      for a in @popast_symscan e => yield a
      for a in @symbols        x => yield a
      for (b, c) in y =>
        for a in @symbols b => yield a
        for a in @symbols c => yield a

    'import', FixedArity 1 ANY $ f (name, *flags) ~>
      qual   = False
      pure   = False
      reload = False

      for flag in flags => if
        flag == 'qualified' => qual   = True
        flag == 'pure'      => pure   = True
        flag == 'reload'    => reload = True
        otherwise => Error flag 'unsupported import flag'

      if
        name :: Constant and name.value :: str =>
          parent, path = except
            err => __dg_parse_import__ name.value
            err :: ImportError => Error name $ str err
          yield $ path !! (-not qual)
          f._impdata = parent, path, qual, pure, reload
        otherwise =>
          for a in @symbols name => yield a
          f._impdata = None, name, qual, pure, reload

    # These create new functions. We shouldn't scan them.
    '->',    _ _ ~> ()
    '~>',    _ _ ~> ()
    'where', _ _ ~> ()

  prefix = dict'
    '',    f xs ~> @pushcall *: xs
    '\n',  f xs ~> @pushlast *: xs
    '=',   FixedArity 2 2 $ f (name, value) ~> @pushpop  name value
    ':=',  FixedArity 2 2 $ f (name, value) ~> @pushpop  name value
    '->',  FixedArity 2 2 $ f (args, body)  ~> @pushfunc args body
    '~>',  FixedArity 2 2 $ f (args, body)  ~> @pushmeth args body
    '!!~', FixedArity 2 2 $ f (coll, item)  ~>
      @pushast   coll
      @pushast   item
      @append    'DELETE_SUBSCR' delta: -2
      @pushconst None

    ':',      WithError 'keyword argument to what?'
    '!',      WithError 'this operator is postfix'
    '~',      WithError 'this operator is prefix'
    '@',      WithError 'this operator is prefix'
    ',',      WithOpcode 'BUILD_TUPLE'
    "set'",   WithOpcode 'BUILD_SET'
    "list'",  WithOpcode 'BUILD_LIST'
    "tuple'", WithOpcode 'BUILD_TUPLE'
    'or',     WithJump   'JUMP_IF_TRUE_OR_POP'
    '=>',     WithJump   'JUMP_IF_FALSE_OR_POP'
    'and',    WithJump   'JUMP_IF_FALSE_OR_POP'
    'not',    FixedArity 1 1 $ WithOpcode 'UNARY_NOT'
    '!!',     FixedArity 2 2 $ WithOpcode 'BINARY_SUBSCR'
    '+',      FixedArity 2 2 $ WithOpcode 'BINARY_ADD'
    '-',      FixedArity 2 2 $ WithOpcode 'BINARY_SUBTRACT'
    '*',      FixedArity 2 2 $ WithOpcode 'BINARY_MULTIPLY'
    '**',     FixedArity 2 2 $ WithOpcode 'BINARY_POWER'
    '/',      FixedArity 2 2 $ WithOpcode 'BINARY_TRUE_DIVIDE'
    '//',     FixedArity 2 2 $ WithOpcode 'BINARY_FLOOR_DIVIDE'
    '%',      FixedArity 2 2 $ WithOpcode 'BINARY_MODULO'
    '&',      FixedArity 2 2 $ WithOpcode 'BINARY_AND'
    '^',      FixedArity 2 2 $ WithOpcode 'BINARY_XOR'
    '|',      FixedArity 2 2 $ WithOpcode 'BINARY_OR'
    '<<',     FixedArity 2 2 $ WithOpcode 'BINARY_LSHIFT'
    '>>',     FixedArity 2 2 $ WithOpcode 'BINARY_RSHIFT'
    '!!=',    FixedArity 2 2 $ Inplace $ WithOpcode 'BINARY_SUBSCR'
    '+=',     FixedArity 2 2 $ Inplace $ WithOpcode 'INPLACE_ADD'
    '-=',     FixedArity 2 2 $ Inplace $ WithOpcode 'INPLACE_SUBTRACT'
    '*=',     FixedArity 2 2 $ Inplace $ WithOpcode 'INPLACE_MULTIPLY'
    '**=',    FixedArity 2 2 $ Inplace $ WithOpcode 'INPLACE_POWER'
    '/=',     FixedArity 2 2 $ Inplace $ WithOpcode 'INPLACE_TRUE_DIVIDE'
    '//=',    FixedArity 2 2 $ Inplace $ WithOpcode 'INPLACE_FLOOR_DIVIDE'
    '%=',     FixedArity 2 2 $ Inplace $ WithOpcode 'INPLACE_MODULO'
    '&=',     FixedArity 2 2 $ Inplace $ WithOpcode 'INPLACE_AND'
    '^=',     FixedArity 2 2 $ Inplace $ WithOpcode 'INPLACE_XOR'
    '|=',     FixedArity 2 2 $ Inplace $ WithOpcode 'INPLACE_OR'
    '<<=',    FixedArity 2 2 $ Inplace $ WithOpcode 'INPLACE_LSHIFT'
    '>>=',    FixedArity 2 2 $ Inplace $ WithOpcode 'INPLACE_RSHIFT'
    'is',     Comparison
    'in',     Comparison
    '<',      Comparison
    '<=',     Comparison
    '==',     Comparison
    '!=',     Comparison
    '>=',     Comparison
    '>',      Comparison

    # `op ::: (lstrength, rstrength)` is handled by the parser.
    ':::', FixedArity 2 2 $ f _ ~> @pushconst None

    '.', FixedArity 2 2 $ f (x, y) ~>
      y :: Name or Error y 'not an attribute'
      @pushast x
      @append  'LOAD_ATTR' $ @names !! y.value

    '!.', FixedArity 2 2 $ f (x, y) ~>
      y :: Name or Error y 'not an attribute'
      @pushcall x
      @append   'LOAD_ATTR' $ @names !! y.value

    '.~', FixedArity 2 2 $ f (x, y) ~>
      y :: Name or Error y 'not an attribute'
      @pushast   x
      @append    'DELETE_ATTR' delta: -1 $ @names !! y.value
      @pushconst None

    '$', FixedArity 2 2 $ f (g, x) ~> if
      g :: Expression and not g.closed and g.op == '' => @pushcall g.op *: (g.args+:x)
      otherwise => @pushcall g x

    #: Import a module given a POSIX-style path.
    #:
    #: import '/sys'                 imports a module named 'sys'
    #: import '/os/path' qualified   imports a module named 'os' with a submodule 'path'
    #: import '/dg/addon/fork'       imports 'fork' from package 'dg.addon'
    #: import 'markup'               imports 'markup' from the current package
    #: import 'smth' pure            imports 'smth', but does not create a new variable
    #: import 'smth' pure reload     as above, but re-evaluates the module even if it
    #:                               was previously imported
    #:
    'import', FixedArity 1 ANY $ f (name, *flags) ~>
      hasattr f '_impdata' or Error name "internal error: should've called @symbols first"
      parent, path, qual, pure, reload = f._impdata

      if
        parent is None or reload =>
          # No opcode allows us to reload the module.
          @pushname '__dg_import__'
          if not $ parent is None => @pushconst (parent, tuple path)
             otherwise =>
               @pushname '__dg_parse_import__'
               @pushast path
               @append 'CALL_FUNCTION' 1 delta: -1
          @pushname  '__package__'
          @pushconst qual
          @pushconst reload
          @append 'CALL_FUNCTION' 4 delta: -4

        qual or (parent == 0 and len path == 1) =>
          @pushconst parent
          @pushconst None
          @append    'IMPORT_NAME' delta: -1 $ @names !! '.'.join path

        otherwise =>
          *dir, file = path
          @pushconst parent
          @pushconst (file,)
          @append    'IMPORT_NAME' delta: -1 $ @names !! '.'.join dir
          @append    'IMPORT_FROM' delta:  1 $ @names !! file
          @append    'ROT_TWO'     delta:  0
          @append    'POP_TOP'     delta: -1

      not pure =>
        parent is None => Error path 'non-pure imports should be constant'
        @append 'DUP_TOP' delta: +1
        @popast $ Name name.loc False $ path !! (-not qual)

    #: Local binding.
    #:
    #: I.e. `a where b` makes stuff from `b` only visible in `a`.
    #:
    'where', FixedArity 2 2 $ f (ret, env) ~>
      g = @spawn '<lambda>'
      g.regsyms  env
      g.regsyms  ret
      g.pushlast env ret
      @pushclosure g tuple! dict!
      @append 'CALL_FUNCTION' 0

    #: Type creation.
    #:
    #: Duplicate the local namespace and turn it into a type. `where` is useful here.
    #:
    'subclass', f args ~>
      @pushname  '__dg_build_class__'  # Note: these may have been redefined
      @pushname  '__name__'            # in this namespace. Watch the syntax highlighting.
      @pushname  'locals'              # (And don't name methods __dg_build_class__.)
      @append    'CALL_FUNCTION' 0
      @pushconst None  # TODO docstring (the first constant in this code object)-
      @pushconst @qualname
      @pushconst @name
      @pushcalltop 5 args

    #: Automatic context managing.
    #:
    #: I think it's called IDisposable or something.
    #:
    'with', FixedArity 2 2 $ f (ctx, body) ~>
      var, ctx = if
        ctx :: Expression and len ctx.args == 2 and ctx.op == '=' => ctx.args
        otherwise => Name ctx.loc False '_', ctx

      @pushconst None  # reserve space for a return value
      @pushast   ctx
      with @jump 'SETUP_WITH' delta: +8 =>  #=> None, __exit__, return value of __enter__
        @popast    var                      #=> None, __exit__
        @pushast   body                     #=> None, __exit__, return value
        @append    'ROT_THREE' delta: +0
        @append    'ROT_TWO'   delta: +0
        @append    'POP_BLOCK' delta: -1     #=> return value, __exit__
        @pushconst None                      # this is for END_FINALLY
      @append 'WITH_CLEANUP' delta: -1
      @append 'END_FINALLY'  delta: -8

    #: Repeat while a condition is true.
    #:
    #: I wonder if there's a nicer way to write interlinked jumps.
    #:
    'while', FixedArity 2 2 $ f (cond, body) ~>
      @pushconst False
      with @jump 'SETUP_LOOP' =>
        restart = @jump 'JUMP_ABSOLUTE' True
        @loops.append $ @jump 'CONTINUE_LOOP' reverse: True
        @pushast cond
        with @jump 'POP_JUMP_IF_FALSE' delta: -1 =>
          @pushast body
          @append  'POP_TOP' delta: -1
          restart.set
        @loops.pop -1
        @append 'POP_BLOCK'
        @append 'POP_TOP'   delta: -1
        @pushconst True

    #: Iterate over a...iterator, duh.
    #:
    #: Note that `var` may be any valid assignment target, not only a local variable.
    #:
    'for', FixedArity 2 2 $ f (var, body) ~>
      # `var` was already syntax-checked in `symscan`.
      @pushconst False
      with @jump 'SETUP_LOOP' =>
        @pushast $ snd var.args
        @append    'GET_ITER'
        restart = @jump 'JUMP_ABSOLUTE' True
        @loops.append $ @jump 'CONTINUE_LOOP' reverse: True
        with @jump 'FOR_ITER' delta: +1 =>
          @popast $ fst var.args
          @pushast  body
          @append   'POP_TOP'   delta: -1
          restart.set
        @loops.pop -1
        @append 'POP_BLOCK' delta: -1
        @append 'POP_TOP'   delta: -1
        @pushconst True

    #: Stop the loop immediately.
    #:
    #: It will also return False.
    #:
    'break', FixedArity 0 0 $ f _ ~> if
      @loops    => @append 'BREAK_LOOP'    delta: +1
      otherwise => Error f '`break` outside of a loop'

    #: Continue on to the next iteration.
    #:
    #: Does not affect the return value of the loop.
    #:
    'continue', FixedArity 0 0 $ f _ ~> if
      @loops    => (last @loops).set
      otherwise => Error f '`continue` outside of a loop'

    #: Yield control to the caller.
    #:
    #: Did you know that generators have a `send` method? Look it up.
    #:
    'yield', FixedArity 1 2 $ f (*flags, it) ~>
      from = False
      for f in flags => if
        f == 'from' => from = True
        otherwise   => Error f 'unrecognized option'

      @generator = True
      @pushast it
      if from      => @append 'GET_ITER', @pushconst None, @append 'YIELD_FROM' delta: -1
         otherwise => @append 'YIELD_VALUE'

    'if', ArrowPairs $ f xs ~>
      jumps = list
        where for (cond, action) in xs => yield $
          @pushast cond
          with @jump 'POP_JUMP_IF_FALSE' delta: -1 =>
            @pushast action
            @jump 'JUMP_FORWARD' delta: -1
      @pushconst None
      for x in jumps => x.set

    'raise', FixedArity 1 1 $ f (exc,) ~>
      # TODO __cause__
      @pushast exc
      @append  'RAISE_VARARGS' 1

    'except', FixedArity 1 ANY $ ArrowPairs $ f ((name, try), *xs) ~>
      @pushconst None
      if xs and head (last xs) == 'finally' => @pushfinally name try xs $ snd $ xs.pop -1
         otherwise                          => @pushexcept  name try xs

  infixl = dict'
    ':', WithError 'keyword argument to what?'
    '~', WithError 'this operator is prefix'
    '@', WithError 'this operator is prefix'

    '!',     f g ~> @pushcall g
    ',',     f x ~> @pushcall f x  # i.e. same as in `prefix`.
    '->',    f x ~> @pushcall f x $ Constant f.loc None  # `x R` => `x R None`
    '~>',    f x ~> @pushcall f x $ Constant f.loc None
    'while', f x ~> @pushcall f x $ Constant f.loc None
    'for',   f x ~> @pushcall f x $ Constant f.loc None
    'where', f x ~> @pushcall f x $ Constant f.loc None

  infixr = dict'
    ':', WithError 'keyword argument to what?'
    '!', WithError 'this operator is postfix'
    ',', WithError 'this operator is unbindable'

    '~',     f x ~> (@pushast x, @append 'UNARY_INVERT')
    '-',     f x ~> (@pushast x, @append 'UNARY_NEGATIVE')
    'where', f x ~>  @pushcall f x $ Constant f.loc None
    '@',     f x ~>  @pushcall (Name f.loc True '.') (Name f.loc False 'self') x

    '->', f body ~> @pushfunc' body () () () dict! () () dict!
    '~>', f body ~>
      @pushname 'property'
      @pushfunc' body ('self',) () () dict! () () dict!
      @append 'CALL_FUNCTION' 1 delta: -1
