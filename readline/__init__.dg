import '/re'
import '/asyncio'
import '/collections'

import 'ansi'
import 'mix'
import 'tty'


ReadlineState = subclass object where
  #: A readline input state.
  #:
  #: Defines stuff such as the current buffer contents, caret position, etc.
  #:
  __init__ = @prompt @buffer @position @cache ~> None

  #: Move the caret to the right.
  #:
  #: right :: int -> ReadlineState
  #:
  right = i ~> ReadlineState @prompt @buffer (@position + i `min` len @buffer) @cache

  #: Move the caret to the left.
  #:
  #: left :: int -> ReadlineState
  #:
  left = i ~> ReadlineState @prompt @buffer (@position - i `max` 0) @cache

  #: Insert a string into the buffer, move the caret if necessary.
  #:
  #: insert :: int str -> ReadlineState
  #:
  insert = i d ~> if
    i < 0     => @insert 0 $ d !! slice (-i) None
    otherwise => ReadlineState @prompt
      (+)
        @buffer !! slice None i + d
        @buffer !! slice i None
      @position + len d * (i <= @position)
      @cache

  #: Erase the characters at position `i`, move the caret accordingly.
  #:
  #: erase :: int (Optional int) -> ReadlineState
  #:
  erase = i length: 1 ~> if
    i < 0     => @erase 0 $ length + i
    otherwise => ReadlineState @prompt
      (+)
        @buffer !! slice None i
        @buffer !! slice (i + length) None
      @position - (length `min` @position - i `max` 0)
      @cache


Readline = subclass object where
  __init__ = *: args **: kwargs ~>
    @tty = tty.Teletype *: args **: kwargs
    @_suspends = 0
    @_suspend = asyncio.Event loop: @tty.loop
    @_restore = asyncio.Event loop: @tty.loop
    None

  #: Pause `input` and execute a function while in that paused state. The prompt
  #: (and everything entered by the user) is temporarily erased from the screen.
  #:
  #: suspend :: (-> coroutine a) -> coroutine a
  #:
  suspend = coro ~>
    @_suspends += 1
    @tty.break
    yield from @_suspend.wait!
    except _       => yield from (asyncio.coroutine coro)!
           finally =>
             @_suspends -= 1
             @_suspends == 0 => @_restore.set!

  #: A mapping of keys to state modificators. Note that a key may be
  #: either a character or an ANSI sequence.
  #:
  #: bindings :: dict str (ReadlineState -> ReadlineState)
  #:
  bindings = dict'
    ansi.Key.ENTER,     state -> raise $ StopIteration state.buffer
    ansi.Key.RIGHT,     state -> state.right 1
    ansi.Key.LEFT,      state -> state.left  1
    ansi.Key.END,       state -> state.right $ len state.buffer
    ansi.Key.END_ALT,   state -> state.right $ len state.buffer
    ansi.Key.HOME,      state -> state.left    state.position
    ansi.Key.HOME_ALT,  state -> state.left    state.position
    ansi.Key.DEL_ANSI,  state -> state.erase   state.position
    ansi.Key.DEL_ASCII, state -> state.erase $ state.position - 1
    ansi.Key.DEL_CTRL,  state -> state.erase $ state.position - 1
    ansi.Key.EOF,       state -> if
      state.buffer => state.erase state.position
      otherwise    => raise $ EOFError state.buffer

  #: Whether to enable ^C and ^Z. Disallows the use of `Key.SIGINT` and `Key.SUSPEND`.
  #:
  #: enable_jobs :: bool
  #:
  enable_jobs = True

  #: Whether to enable XON/XOFF, whatever that means. Disables `Key.XON` and `Key.XOFF`.
  #:
  #: enable_flowctl :: bool
  #:
  enable_flowctl = False

  #: Default line preprocessor. Does nothing.
  #:
  #: This method is called whenever an updated display is required.
  #: Its only argument is the buffer, and the return value should
  #: be an ANSI-escaped string to display. This could be used,
  #: for example, to implement syntax highlighting.
  #:
  #: NOTE: this method must NOT change the apparent length of a string.
  #:   Otherwise, the caret will appear in the wrong position.
  #:
  #: preprocess :: str -> str
  #:
  preprocess = ln ~> ln

  #: Read a line from a TTY while displaying a preview on another TTY.
  #:
  #: If the prompt is a function, it will be called with the current
  #: `ReadlineState` whenever the display is updated.
  #:
  #: input :: (Either str (ReadlineState -> str)) -> str
  #:
  input = prompt ~>
    with @tty.raw @enable_jobs @enable_flowctl => except
      error =>
        state = ReadlineState prompt '' 0 dict!
        @update state
        while True => if
          @_suspends =>
            @_suspend.set!
            @erase state
            yield from @_restore.wait!
            @update state
            @_restore.clear!
            @_suspend.clear!

          otherwise =>
            for c in yield from @tty.buffer => state = if
              c in @bindings   => (@bindings !! c) state
              @tty.printable c => state.insert state.position c
              otherwise        => state  # ignore unrecognized special commands
            @update state
      finally => @finalize state

  #: Write a preview of a line buffer onto a TTY.
  #:
  #: update :: ReadlineState -> ReadlineState
  #:
  update = state ~>
    prefix = if
      state.prompt :: collections.Callable => state.prompt state
      otherwise => state.prompt
    prelen = @tty.ansi_len prefix
    # We're going to assume the VT handles windows resizing correctly
    # (i.e. rewraps long lines.)
    wh, ww = @tty.size
    h, w = prelen + len state.buffer `divmod` ww
    y, x = prelen + state.position   `divmod` ww
    # 1. Go to where the last prompt started, overwrite it with new data.
    #    If its start is already off the screen, we'll just go where we can.
    @erase state
    @tty.write $ prefix + @preprocess state.buffer
    # 2. Go back to the beginning. Note: if the string fits
    #    exactly on one line and the cursor is still there,
    #    VTs won't create an empty line.
    if w == 0 and (y, x) != (h, w) => @tty.relmove (1 - h) (-ww)
       otherwise => @tty.relmove (-h) (-w)
    # 3. Move to where the caret should be. Note that (0, 0) may be off-screen,
    #    and terminals will truncate offsets.
    @tty.relmove (y - (h - wh `max` 0)) x
    @tty.flush!
    # The next `update` will use that info.
    state.cache !! 'lastpos'  = prelen + state.position
    state.cache !! 'termsize' = wh, ww
    state

  #: Move the cursor to the start of the prompt and erase it.
  #:
  #: erase :: ReadlineState -> ReadlineState
  #:
  erase = state ~>
    _h, _w = state.cache.get 'termsize' (0, 1)
    _y, _x = state.cache.pop 'lastpos' 0 `divmod` _w
    @tty.relmove (-_y) (-_x)
    @tty.erase
    state

  #: Move the cursor to the end of the text.
  #: This allows key handlers to print other stuff between prompts.
  #: Don't forget to call `update` later.
  #:
  #: finalize :: ReadlineState -> ReadlineState
  #:
  finalize = state ~>
    @update $ state.right $ len state.buffer - state.position
    @tty.write '\n\r'
    state.cache.pop 'lastpos' 0
    state
