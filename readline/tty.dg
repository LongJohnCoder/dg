import '/os'
import '/time'
import '/fcntl'
import '/codecs'
import '/struct'
import '/select'
import '/asyncio'
import '/termios'
import '/contextlib'

import 'ansi/Sequence'


Protocol = subclass asyncio.Protocol where
  __init__ = loop encoding ~>
    @loop = loop
    @done = False
    @news = asyncio.Event loop: loop
    @data = ''
    @dec  = (codecs.getincrementaldecoder encoding) 'surrogateescape'
    asyncio.Protocol.__init__ self

  data_received = buf ~>
    @data += @dec.decode buf
    @news.set!
    asyncio.Protocol.data_received self buf

  connection_lost = exc ~>
    @done = True
    @data += @dec.decode b'' True
    @news.set!
    asyncio.Protocol.connection_lost self exc

  wait = ~>
    except _       => @data or yield from @news.wait!
           finally => @done or @news.clear!
    result, nl, @data = @data.partition '\n'
    result + nl


Teletype = subclass object where
  #: Various TTY-related functions.
  #:
  #: input  :: TextIOBase -- 'r'-mode TTY.
  #: output :: TextIOBase -- 'w'-mode TTY.
  #:
  __init__ = @input @output loop: None @name: None ~>
    not @input .isatty! => raise $ IOError 'input: not a tty'
    not @output.isatty! => raise $ IOError 'output: not a tty'
    @loop  = loop or asyncio.get_event_loop!
    @proto = None

  write = ~> @output.write
  flush = ~> @output.flush
  break = ~> @proto and @proto.news.set!

  #: Determine the length of an ANSI-escaped string. ANSI escapes are assumed to be empty.
  #:
  #: ansi_len :: str -> int
  #:
  ansi_len = classmethod $ data ~> len $ Sequence.sub (m -> m.group 1 or '') data

  #: Check whether a key's value is printable.
  #:
  #: printable :: str -> bool
  #:
  printable = classmethod $ data ~> if
    len data == 0 => True
    len data == 1 => 32 <= ord data < 127 or 160 <= ord data

  #: Enter the raw mode of a TTY.
  #:
  #: raw :: bool bool :: Context NoneType
  #:
  raw = contextlib.contextmanager $ jobctl flowctl ~>
    old = termios.tcgetattr @input
    new = termios.tcgetattr @input
    new !! 0 &= ~(termios.ISTRIP | termios.IXON)
    new !! 3 &= ~(termios.ECHO   | termios.ICANON | termios.IEXTEN | termios.ISIG)
    if flowctl => new !! 0 |= termios.IXON
    if jobctl  => new !! 3 |= termios.ISIG
    except error   => yield $ termios.tcsetattr @input termios.TCSADRAIN new
           finally =>         termios.tcsetattr @input termios.TCSAFLUSH old

  #: Find out how much stuff this TTY can display at once.
  #:
  #: size :: (int, int) -- (height, width) in characters
  #:
  size = ~> struct.unpack 'hh' $ fcntl.ioctl @output termios.TIOCGWINSZ '1234'

  #: Wait until some data on the terminal.
  #:
  #: buffer :: iter str
  #:
  buffer = ~>
    @proto is None =>
      yield from $ @loop.connect_read_pipe (-> @proto = Protocol @loop @input.encoding) @input
    map (x -> x.group!) $ Sequence.finditer $ yield from @proto.wait

  #: Move the caret `y` characters down and `x` characters to the right.
  #:
  #: relmove :: int int -> a
  #:
  relmove = y x ~> @write $ (+)
    if y > 0     => '\033[{}B'.format y
       y < 0     => '\033[{}A'.format (-y)
       otherwise => ''  # If `y` is 0, terminals might assume 1.
    if x > 0     => '\033[{}C'.format x
       x < 0     => '\033[{}D'.format (-x)
       otherwise => ''

  #: Erase everything from the cursor to the end of the screen.
  #:
  #: erase :: a
  #:
  erase = ~> @write '\033[J'
