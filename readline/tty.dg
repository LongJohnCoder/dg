import '/os'
import '/time'
import '/fcntl'
import '/codecs'
import '/struct'
import '/select'
import '/asyncio'
import '/termios'
import '/contextlib'

import 'ansi/Sequence'


Teletype = subclass asyncio.Protocol where
  #: Various TTY-related functions.
  #:
  #: input  :: TextIOBase -- 'r'-mode TTY.
  #: output :: TextIOBase -- 'w'-mode TTY.
  #:
  __init__ = @input @output @name: None loop: None ~>
    not @input .isatty! => raise $ IOError 'input: not a tty'
    not @output.isatty! => raise $ IOError 'output: not a tty'
    @_data = ''
    @_done = False
    @_task = None
    @_loop = loop or asyncio.get_event_loop!
    @_wait = @_loop.connect_read_pipe (-> self) @input
    @_dec  = (codecs.getincrementaldecoder @input.encoding) 'surrogateescape'
    (super Teletype self).__init__!

  write = ~> @output.write
  flush = ~> @output.flush

  #: Determine the length of an ANSI-escaped string. ANSI escapes are assumed to be empty.
  #:
  #: ansi_len :: str -> int
  #:
  ansi_len = classmethod $ data ~> sum $
    where for x in Sequence.findall data => len x == 1 => yield 1

  #: Check whether a key's value is printable.
  #:
  #: printable :: str -> bool
  #:
  printable = classmethod $ data ~> if
    len data == 0 => True
    len data >= 2 => False  # only ANSI sequences match this
    otherwise     => 32 <= ord data < 127 or 160 <= ord data

  #: Enter the raw mode of a TTY.
  #:
  #: raw :: bool bool :: Context NoneType
  #:
  raw = contextlib.contextmanager $ jobctl flowctl ~>
    old = termios.tcgetattr @input
    new = termios.tcgetattr @input
    new !! 0 &= ~(termios.ISTRIP | termios.IXON)
    new !! 3 &= ~(termios.ECHO   | termios.ICANON | termios.IEXTEN | termios.ISIG)
    if flowctl => new !! 0 |= termios.IXON
    if jobctl  => new !! 3 |= termios.ISIG
    except error   => yield $ termios.tcsetattr @input termios.TCSADRAIN new
           finally =>         termios.tcsetattr @input termios.TCSAFLUSH old

  #: Find out how much stuff this TTY can display at once.
  #:
  #: size :: (int, int)
  #:
  size = ~>
    # FIXME what would happen if a Windows SSH client connects to a UNIX server?
    #   I sure hope that client emulates UNIX terminals.
    struct.unpack 'hh' $ fcntl.ioctl @output termios.TIOCGWINSZ '1234'

  #: Wait until some data on the terminal.
  #:
  #: buffer :: str
  #:
  buffer = ~>
    @_wait =>
      yield from @_wait
      @_wait = None
    result = if
      @_task    => raise $ RuntimeError 'already waiting on this input'
      @_data    => @_data
      @_done    => @_data
      otherwise => except
        _       => yield from (@_task = asyncio.Future loop: @_loop)
        finally => @_task = None
    @_data = ''
    Sequence.findall result

  data_received = buf ~>
    @_data += @_dec.decode buf
    @_task and not @_task.done! => @_task.set_result @_data
    (super Teletype self).data_received buf

  connection_lost = exc ~>
    @_done = True
    @_data += @_dec.decode b'' True
    @_task => @_task.set_result @_data
    (super Teletype self).connection_lost exc

  #: Move the caret `y` characters down and `x` characters to the right.
  #:
  #: relmove :: int int -> a
  #:
  relmove = y x ~> @write $ (+)
    if y > 0     => '\033[{}B'.format y
       y < 0     => '\033[{}A'.format (-y)
       otherwise => ''  # If `y` is 0, terminals might assume 1.
    if x > 0     => '\033[{}C'.format x
       x < 0     => '\033[{}D'.format (-x)
       otherwise => ''

  #: Erase everything from the cursor to the end of the screen.
  #:
  #: erase :: a
  #:
  erase = ~> @write '\033[J'
